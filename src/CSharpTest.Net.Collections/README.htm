<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
    <title>BPlusTree - README</title>
</head>
<body>
<h3>Overview</h3>
<a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602_members.html" target="_blank">BPlusTree</a> is a implementation of the generic <a href="http://msdn.microsoft.com/en-us/library/s4ys34ea.aspx" target="_blank">IDictionary&lt;TKey, TValue&gt;</a> interface backed by a disk-based B+Tree. There is no practical size limit on the total amount of data that be stored or on the size of the key or value data used. Keys and values can be any class, struct, or built-in primitive written in .NET provided that you can supply an implementation of <a href="http://help.csharptest.net/?CSharpTest.Net.Library~CSharpTest.Net.Serialization.ISerializer%601_members.html" target="_blank">ISerializer&lt;T&gt;</a> to read and write the object. There are also several available storage, concurrency, and caching strategies available to choose from.
<h3>Storage</h3>
All storage systems implement a single interface, <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.INodeStorage_members.html" target="_blank">INodeStorage</a>. This interface is responsible for the creation, reading, writing, and deletion of a node in the tree. You can implement your own storage subsystem and provide it to the options class via the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~StorageSystem.html" target="_blank">StorageSystem</a> property. Most of the time you will want to use one of the two forms of storage BPlusTree supports by default each of which have numerous options.

File Storage - The first and most common of these storage types is the file based storage. To use the file store simply specify the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~FileName.html" target="_blank">FileName</a> property and the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CreateFile.html" target="_blank">CreateFile</a> policy on the Options class. The file storage uses a fixed block sub-allocation scheme to allocate blocks within the specified file. This block size can be specified or left as the 4kb default. The other important setting here is the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~FileOpenOptions.html" target="_blank">FileOpenOptions</a> setting which allows you to specify a combination of the <a href="http://msdn.microsoft.com/en-us/library/system.io.fileoptions.aspx" target="_blank">System.IO.FileOptions</a> flags. Both WriteThrough and NoBuffering (FILE_FLAG_NO_BUFFERING = 0x20000000, see <a href="http://msdn.microsoft.com/en-us/library/cc644950(v=VS.85).aspx" target="_blank">File Buffering</a>) are supported. Using the WriteThrough and NoBuffering options provides you with the most durable storage at a significant performance cost.

Memory Storage - Most of the time this is fairly useless as the whole B+Tree goes since you would ordinarily just use a regular Dictionary&lt;TKey, TValue&gt;. It is possible the BPlusTree can outperform a Monitor locked Dictionary; however, real world use cases of the excessive contention required seem unlikely. If you simply must have an IDictionary that is completely thread safe you are welcome to give it a try, just set the StorageType property on the options class to Memory.
<h3>Concurrency</h3>
Concurrent reads and writes are completely safe. By default writers do not block readers so a reader is only guaranteed to read a modification if the read operation began after the completion of the write. In addition the use of localized node level locking for writers allows multiple concurrent writers to co-exist in different locations of the tree.

The BPlusTree uses an implementation of an <a href="http://help.csharptest.net/?CSharpTest.Net.Library~CSharpTest.Net.Interfaces.IFactory%601_members.html" target="_blank">IFactory&lt;ILockStrategy&gt;</a> to construct locks for each node read from the store. The default <a href="http://help.csharptest.net/?CSharpTest.Net.Library~CSharpTest.Net.Synchronization.ILockStrategy_members.html" target="_blank">ILockStrategy</a> uses a <a href="http://msdn.microsoft.com/en-us/library/system.threading.monitor.aspx" target="_blank">Monitor</a> <a href="http://msdn.microsoft.com/en-us/library/4tssbxcw.aspx" target="_blank">TryEnter</a>/<a href="http://msdn.microsoft.com/en-us/library/system.threading.monitor.exit.aspx" target="_blank">Exit</a> to control access only for writers. If you are using the BPlusTree from a single thread, or you are opening it in <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~ReadOnly.html" target="_blank">ReadOnly</a> mode, then you can disable the locking by setting the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~LockingFactory.html" target="_blank">LockingFactory</a> property of the Options class to an instance of the <a href="http://help.csharptest.net/?CSharpTest.Net.Library~CSharpTest.Net.Synchronization.IgnoreLockFactory_members.html" target="_blank">IgnoreLockFactory</a> class.

With a few exceptions all public members and enumerators are completely thread safe by default. Those exceptions are diagnostics methods like Print, and Validate, as well as the methods <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602~EnableCount.html" target="_blank">EnableCount</a>, Clear, and UnloadCache. All of these methods may be made thread safe by specifying a valid reader/writer lock (i.e. <a href="http://help.csharptest.net/?CSharpTest.Net.Library~CSharpTest.Net.Synchronization.SimpleReadWriteLocking.html" target="_blank">SimpleReadWriteLocking</a>) on the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CallLevelLock.html" target="_blank">CallLevelLock</a> property of the options class. In addition once the CallLevelLock is set you can obtain a Write lock on this to obtain exclusive access to the entire tree.
<h3>Caching</h3>
The cache is fairly baked into the implementation at present and is therefore not extensible; however, there are several options to control its behavior. Setting the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CachePolicy.html" target="_blank">CachePolicy</a> of the Options class is the primary control allowing for None (nothing is cached, everything is read from disk), Recent (high utilization nodes are kept in memory), and All (everything is kept in cache).

The default is Recent and this cache option has a few options of its own. The <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CacheKeepAliveMinimumHistory.html" target="_blank">CacheKeepAliveMinimum</a>/<a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CacheKeepAliveMaximumHistory.html" target="_blank">MaximumHistory</a> properties control the range of items allowed to be cached while the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~CacheKeepAliveTimeout.html" target="_blank">CacheKeepAliveTimeout</a> defines how quickly the cache should be reduced back to the minimum value. It is important to note that these numbers do not reflect unique nodes, but rather include each visit to a node. By default the cache holds at least the most recent 10 nodes visited and at most the last 100 nodes visited. With mild activity this cache will reduced itself after 1 minute. Please note that the BPlusTree does not create or manage threads so without some level of activity the cache may remain at its maximum capacity.
<h3>Fault Tolerance</h3>
What can go wrong will go wrong. Every effort has been made to ensure that the BPlusTree continues to behave even when things don’t go as expected. All modifications to the tree and the file are transacted internally to ensure modifications to the data or tree remain atomic and either complete or fail as a single unit.

Because of the fact that threads may be killed by unmanaged code or other catastrophic thread event (stack overflow, stack corruption) there may be a case when .NET’s Monitor becomes confused about who owns it. If this happens every call to the BPlusTree may throw a <a href="http://msdn.microsoft.com/en-us/library/system.timeoutexception.aspx" target="_blank">TimeoutException</a> when attempting to acquire a lock. This is the other reason apart from regaining memory for the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602~UnloadCache.html" target="_blank">UnloadCache</a> method (see Concurrency and the CallLevelLock property).

Though I’ve never seen it happen under normal circumstances, if your file does become corrupt you can attempt to recover the data with the <a href="http://help.csharptest.net/CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602~RecoverFile.html" target="_blank">RecoverFile</a>/<a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602~RecoveryScan.html" target="_blank">RecoveryScan</a>.
<h3>Multiple Instances</h3>
Multiple instances of a BPlusTree using the same file is not supported unless the <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602+Options~ReadOnly.html" target="_blank">ReadOnly</a> property on the Options class is set to true. Though it is possible to build this into or on top of the BPlusTree I personally prefer to use a single instance and IPC/RPC to allow cross-domain or cross-process access.
<h3>Exception-less Errors</h3>
Although BPlusTree supports the IDictionary interface the public methods available directly on the class do not always mirror those semantics. You should note that the public Add method returns a boolean result. This is also true for the Update, AddOrUpdate, and Remove methods. If you like exceptions using the IDictionary method Add with an existing key will raise one for you.

<h3>Simple Example:</h3>
<pre style="border: solid 1px black; font-family: Courier New, Courier; font-size: 10.0pt;">

&nbsp;&nbsp;&nbsp; <span style="color: #2B91AF">BPlusTree</span>&lt;<span style="color: blue">string</span>,<span style="color: #2B91AF">Guid</span>&gt;.<span style="color: #2B91AF">Options</span> options = <span style="color: blue">new</span> <span style="color: #2B91AF">BPlusTree</span>&lt;<span style="color: blue">string</span>, <span style="color: #2B91AF">Guid</span>&gt;.<span style="color: #2B91AF">Options</span>(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #2B91AF">PrimitiveSerializer</span>.String, <span style="color: #2B91AF">PrimitiveSerializer</span>.Guid, <span style="color: #2B91AF">StringComparer</span>.Ordinal)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CreateFile = <span style="color: #2B91AF">CreatePolicy</span>.IfNeeded,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FileName = <span style="color: #A31515">@&quot;C:\Temp\Storage.dat&quot;</span>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };

&nbsp;&nbsp;&nbsp; <span style="color: blue">using</span>(<span style="color: #2B91AF">BPlusTree</span>&lt;<span style="color: blue">string</span>, <span style="color: #2B91AF">Guid</span>&gt; map = <span style="color: blue">new</span> <span style="color: #2B91AF">BPlusTree</span>&lt;<span style="color: blue">string</span>,<span style="color: #2B91AF">Guid</span>&gt;(options))
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #2B91AF">Assert</span>.IsTrue(map.Add(<span style="color: #A31515">&quot;foo&quot;</span>, <span style="color: #2B91AF">Guid</span>.NewGuid()), <span style="color: #A31515">&quot;Failed to add foo&quot;</span>);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="color: #2B91AF">Assert</span>.IsTrue(map.ContainsKey(<span style="color: #A31515">&quot;foo&quot;</span>), <span style="color: #A31515">&quot;Failed to find foo&quot;</span>);
&nbsp;&nbsp;&nbsp; }

</pre>

<h3>Online Resources</h3>
<ul>
    <li>Online Help - <a href="http://help.csharptest.net/?CSharpTest.Net.BPlusTree~CSharpTest.Net.Collections.BPlusTree%602_members.html" target="_blank">http://help.csharptest.net/</a></li>
    <li>Source Code - <a href="http://csharptest.net/browse/src/BPlusTree" target="_blank">http://code.google.com/p/csharptest-net/</a></li>
    <li>Downloads - <a href="http://code.google.com/p/csharptest-net/downloads/list" target="_blank">http://code.google.com/p/csharptest-net/downloads</a></li>
    <li>NuGet Package - <a href="http://nuget.org/List/Packages/CSharpTest.Net.BPlusTree" target="_blank">http://nuget.org/List/Packages/CSharpTest.Net.BPlusTree</a></li>
</ul>

</body>
</html>